/*!
 * SQL Tree - Utility for navigating the SQL AST generated by the sqlQueryParser
 */
module.exports = (function (_, sqlQueryParser) {
  var Tree;

  Tree = function Tree(t) {
    if (!(this instanceof Tree)) {
      return new Tree(t);
    }
    this.tree = Tree.safeTree(t);
  };

  _.mixin(Tree.prototype, {
    'has': function has(thing) {
      return this.any(thing) != this.tree;
    },
    'any': function any(thing) {
      return this.branch(_.findWhere(this.tree, thing, this));
    },
    'eachOf': function eachOf(things) {
      return _.all(Tree.matchable(things), this.has, this);
    },
    'anyOf': function anyOf(things) {
      return _.any(Tree.matchable(things), this.has, this);
    },
    'clause': function clause(prop) {
      return this.branch(_.result(this.tree, prop));
    },
    'statement': function statement(stmt) {
      return this.any({
        'type': 'statement',
        'variant': stmt
      });
    },
    'branch': function branch(ast) {
      return Tree.isTree(ast) ? new Tree(_.cloneDeep(ast)) : this.tree;
    },
    'raw': function raw() {
      return this.tree;
    }
  });

  _.mixin(Tree, {
    'matchable': function matchable(things) {
      if (!_.isArray(things)) {
        things = [things];
      }
      return _.map(things, function(thing) {
        return _.isString(thing) ? {'type': thing} : thing;
      }, this);
    },
    'isTree': function isTree(tree) {
      return !_.isUndefined(tree) &&
             _.isObject(tree) &&
             _.keys(tree).length;
    },
    'safeTree': function safeTree(tree) {
      if (_.isString(tree)) {
        if(/^\s*\{.*\}\s*$/.test(tree)) {
          tree = JSON.parse(tree);
        } else {
          tree = sqlQueryParser(tree, true);
        }
      }
      return _.isEqual(_.keys(tree), ['statement'])?
          tree['statement'] :
          tree;
    }
  });

  return Tree;
})(require('lodash'), require('./index'));
