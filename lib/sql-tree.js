/*!
 * SQL Tree - Utility for navigating the SQL AST generated by the sqlQueryParser
 */
module.exports = function (Promise, _, sqlQueryParser) {
  var Tree;

  Tree = function Tree(tree) {
    return new Promise(function(acc, rej) {
      if (_.isString(tree)) {
        if(/^\s*\{.*\}\s*$/.test(tree)) {
          // JSON string
          tree = JSON.parse(tree);
        } else {
          // SQL string
          tree = sqlQueryParser(tree, true);
        }
      }
      acc(_.isEqual(_.keys(tree), ['statement']) ? tree['statement'] : tree);
    });
  };

  _.mixin(Tree, {
    'any': function any(things) {
      return function (tree) {
        var i, len, ref, res, thing;

        ref = Tree.matchable(things);
        for (i = 0, len = ref.length; i < len; i++) {
          thing = ref[i];
          res = _.findWhere(tree, thing);
          if (res != null) {
            return res;
          }
        }
        return null;
      };
    },
    'eachOf': function eachOf(things) {
      return function (tree) {
        return _.all(Tree.matchable(things), function (thing) {
          return _.isFunction(thing) ? thing(tree) != null : Tree.any(thing)(tree);
        });
      };
    },
    'anyOf': function anyOf(things) {
      return function (tree) {
        return Tree.any(things)(tree) != null;
      };
    },
    'clause': function clause(prop) {
      return function (tree) {
        return _.result(tree, prop);
      };
    },
    'statement': function statement(stmt) {
      return Tree.any({
        'type': 'statement',
        'variant': stmt
      });
    },
    'matchable': function matchable(things) {
      if (!_.isArray(things)) {
        things = [things];
      }
      return _.map(things, function(thing) {
        return _.isString(thing) ? {'type': thing} : thing;
      });
    },
    'binary': function () {
      return Tree.any({
        'type': 'expression',
        'format': 'binary'
      });
    },
    'string': function () {
      return Tree.any({
        'type': 'literal',
        'variant': 'string'
      });
    },
    'identifier': function () {
      return Tree.any({
        'type': 'identifier'
      });
    },
    'select':       function () { return Tree.statement('select'); },
    'create':       function () { return Tree.statement('create'); },
    'insert':       function () { return Tree.statement('insert'); },
    'drop':         function () { return Tree.statement('drop'); },
    'delete':       function () { return Tree.statement('delete'); },
    'update':       function () { return Tree.statement('update'); },
    'transaction':  function () { return Tree.statement('transaction'); },
    'where':        function () { return Tree.clause('where'); },
    'from':         function () { return Tree.clause('from'); },
    'order':        function () { return Tree.clause('order'); },
    'limit':        function () { return Tree.clause('limit'); },
    'result':       function () { return Tree.clause('result'); },
    'having':       function () { return Tree.clause('having'); },
    'group':        function () { return Tree.clause('group'); },
    'column':       function (name) {
      return Tree.any({
        'type': 'definition',
        'variant': 'column',
        'name': name
      });
    },
    'constraints':   function () { return Tree.clause('definition'); },
    'constraint':    function (type) {
      return Tree.any({
        'type': 'constraint',
        'variant': type
      });
    }
  });

  return Tree;
};
